
##对象的分配策略
###栈上分配
######逃逸分析
逃逸分析的原理：分析对象动态作用域，当一个对象在方法中定义后，它是否可能逃出这个方法作用域被外部方法所引用。  
比如：调用参数传递到其他方法中或是本方法中创建但作为返回值返回给上层方法，这种称之为方法逃逸。  
甚至还有可能被外部线程访问到，例如：赋值给其他线程中访问的变量，如赋值给了成员变量 其他线程再访问成员变量，这种称之为线程逃逸。  
没有可能逃逸出当前方法被外部访问到 称为不可逃逸  
从不可逃逸到方法逃逸到线程逃逸，称之为对象由低到高的不同逃逸程度。  
如果确定一个对象不会逃逸出线程之外 不可逃逸 那么让对象在栈上分配内存可以就提高 JVM 的效率。因为栈帧结束 内存就自动释放了 对栈上分配的对象来说不用垃圾回收 肯定效率更高。  

**逃逸分析不可逃逸代码示例：见提交点代码 EscapeAnalysisTest**  
示例代码在调用的过程中 Myboject 这个对象属于不可逃逸，JVM 可以做栈上分配。

但如果关闭逃逸分析 并打印gc日志:  
> -XX:-DoEscapeAnalysis     逃逸分析默认开启的 这里如果用-关闭了逃逸分析 那么所有对象都不会栈上分配  
  -XX:+PrintGC  
> 
再运行这段，对象都在堆上分配，通过gc日志会看到频繁触发垃圾回收（垃圾回收会影响系统性能），导致代码运行慢。  

**栈上分配**: 对那些作用于不会逃逸出方法的对象，在分配内存时，不在将对象分配在堆内存中，而是将对象属性打散后分配在线程私有栈内存上，这样随着方法调用结束，栈上分配打散的对象也被回收掉，不在增加 GC 额外压力。  
栈上分配前提条件：开启逃逸分析 & 开启标量替换    两个参数都是默认开启的 （1.6后）  
开启逃逸分析（允许判断对象是否可以逃逸出函数体）： (-XX:+DoEscapeAnalysis)  
开启标量替换（允许对象根据属性打散分配到栈上） ：(-XX:+EliminateAllocations)  





